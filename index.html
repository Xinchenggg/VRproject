<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title>My first three.js app</title>
	<style>
		body {
			margin: 0;
		}
	</style>
</head>

<body>
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
	<script type="importmap">
		{
			"imports": {
				"three": "https://unpkg.com/three@0.139.2/build/three.module.js"
			}
		}
    </script>
    <script type="module">
		import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js';
		import { KTX2Loader } from 'https://unpkg.com/three/examples/jsm/loaders/KTX2Loader.js';
		import { MeshoptDecoder } from 'https://unpkg.com/three/examples/jsm/libs/meshopt_decoder.module.js';
        import { BoxLineGeometry } from 'https://unpkg.com/three/examples/jsm/geometries/BoxLineGeometry.js';
        import { VRButton } from 'https://unpkg.com/three/examples/jsm/webxr/VRButton.js'
		import { XRControllerModelFactory } from 'https://unpkg.com/three/examples/jsm/webxr/XRControllerModelFactory.js';
        import { DecalGeometry } from 'https://unpkg.com/three/examples/jsm/geometries/DecalGeometry.js';

        // Setup and constant
        const radius = 0.08;
        let count = 0;
        let normal = new THREE.Vector3();
        const relativeVelocity = new THREE.Vector3();
        const clock = new THREE.Clock();

        // Setup scene, camera, renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x505050 );

        // Setup camera
		const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.set( 0, 3, 3);
		camera.lookAt( new THREE.Vector3( 0, 2, 0 ) );  // not working

        // Setup renderer
		const renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.outputEncoding = THREE.sRGBEncoding;
		document.body.appendChild( renderer.domElement );
        renderer.shadowMap.enabled = true;
		renderer.shadowMapSoft = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;

		// Add VR DOM, initialize XR
        document.body.appendChild( VRButton.createButton( renderer ) );
        renderer.xr.enabled = true;

        // Add camera orbit control
		// controls.update() must be called after any manual changes to the camera's transform
		let controls = new OrbitControls( camera, renderer.domElement );
		controls.listenToKeyEvents( window ); // optional

		controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
		controls.dampingFactor = 0.05;
		controls.screenSpacePanning = false;
		controls.minDistance = 1;
		controls.maxDistance = 50;
		// controls.maxPolarAngle = Math.PI / 2;    // Limit camera angle to look up

        // Add directional light
		// const directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );

		// directionalLight.position.set( 0, 10, 0 );
		// directionalLight.target.position.set( 0, 0, 0 );
		// scene.add( directionalLight.target );
 
		// directionalLight.castShadow = true;
		// directionalLight.shadow.camera.near = 3;
		// directionalLight.shadow.camera.far = 20;		// Length
		// directionalLight.shadow.camera.top = 10;		// Median to top
		// directionalLight.shadow.camera.bottom = -10;	// Median to bottom
		// directionalLight.shadow.camera.right = 10;		// Median to right
		// directionalLight.shadow.camera.left = -10;		// Median to left
		// directionalLight.shadow.mapSize.set( 4096, 4096 );	// Shadow resolution
        // directionalLight.shadow.radius = 10;     // not working
		// scene.add( directionalLight );

        // Add spot light
        const spotLight = new THREE.SpotLight( 0xffffff, 0.8 )
        spotLight.castShadow = true;
        spotLight.position.set(0,10,0);
        spotLight.target.position.set( 0, 0, 0 );
        spotLight.shadow.camera.near = 2;
        spotLight.shadow.camera.far = 12;
        spotLight.shadow.camera.fov = 30;
		// spotLight.shadow.mapSize.set( 4096, 4096 );	// Shadow resolution
        spotLight.shadow.radius = 1; 
        scene.add(spotLight)
        scene.add(spotLight.target)

        // Create room space
        const room = new THREE.LineSegments(
            new BoxLineGeometry( 10, 10, 10, 1, 1, 1 ),
            new THREE.LineBasicMaterial( { color: 0x808080 } )
        );
        room.geometry.translate( 0, 3, 0 );
        scene.add( room );

        // Add plane as floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry( 10, 10 ), 
            new THREE.MeshStandardMaterial( { color: 0x695d45, side: THREE.DoubleSide } ) 
        );

		floor.position.set( 0, 0, 0 );
		floor.rotation.set( Math.PI/2 , 0, 0 );
		floor.receiveShadow = true;
		scene.add( floor );

        // Add plan as walls
        const wallGeometry = new THREE.PlaneGeometry( 10, 10 );
        const wallMaterial = new THREE.MeshStandardMaterial( { color: 0x4f4f4f, side: THREE.DoubleSide } );

        const wall1 = new THREE.Mesh( wallGeometry,wallMaterial );
		wall1.position.set( 0, 3, -5 );
		wall1.rotation.set( 0 ,0, 0 );
		wall1.receiveShadow = true;
		scene.add( wall1 );

        const wall2= new THREE.Mesh( wallGeometry,wallMaterial );
		wall2.position.set( 5, 3, 0 );
		wall2.rotation.set( 0 ,Math.PI/2, 0 );
		wall2.receiveShadow = true;
		scene.add( wall2 );

        const wall3= new THREE.Mesh( wallGeometry,wallMaterial );
		wall3.position.set( -5, 3, 0 );
		wall3.rotation.set( 0 ,Math.PI/2, 0 );
		wall3.receiveShadow = true;
		scene.add( wall3 );

        const wall4= new THREE.Mesh( wallGeometry,wallMaterial );
		wall4.position.set( 0, 3, 5 );
		wall4.rotation.set( 0 ,0, 0 );
		wall4.receiveShadow = true;
		scene.add( wall4 );

        // Mass-generate balls
        const t0 = performance.now();
        for ( let i = 0; i < 500; i ++ ) {

            const object = new THREE.Mesh(
                new THREE.SphereGeometry( radius, 16, 8 ),
                new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } )
            );

            object.castShadow = true;
            object.receiveShadow = true;
            object.position.set( 0.5, 0, 0 );

            object.position.x = Math.random() * 4 - 2;
            object.position.y = Math.random() * 4;
            object.position.z = Math.random() * 4 - 2;

            object.userData.velocity = new THREE.Vector3();
            object.userData.velocity.x = Math.random() * 0.01 - 0.005;
            object.userData.velocity.y = Math.random() * 0.01 - 0.005;
            object.userData.velocity.z = Math.random() * 0.01 - 0.005;

            room.add( object );

        }
        const t1 = performance.now();
        console.log(`${t1 - t0} milliseconds.`);

        // Add controllers
		let controller1, controller2;		// Right, Left
		let controllerGrip1, controllerGrip2;

		controller1 = renderer.xr.getController( 0 );
		controller1.addEventListener( 'selectstart', onSelectStart );
		controller1.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller1 );

		controller2 = renderer.xr.getController( 1 );
		controller2.addEventListener( 'selectstart', onSelectStart );
		controller2.addEventListener( 'selectend', onSelectEnd );
		scene.add( controller2 );

        // Add default model to controller
        const controllerModelFactory = new XRControllerModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip( 0 );
        controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
        scene.add( controllerGrip1 );

        controllerGrip2 = renderer.xr.getControllerGrip( 1 );
        controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
        scene.add( controllerGrip2 );

        // Add pointing line for controllers
		const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3( 0, 0, 0 ), 
            new THREE.Vector3( 0, 0, - 1 )
        ]);

        const lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff } );

        const line = new THREE.Line( lineGeometry, lineMaterial );
        line.name = 'line';
        line.scale.z = 5;

        // Attach line to controllers
        controller1.add( line.clone() );
        controller2.add( line.clone() );

        // Controller functions
        function onSelectStart() {
            this.userData.isSelecting = true;
        }

        function onSelectEnd() {
            this.userData.isSelecting = false;
        }

        function handleController( controller ) {

            if ( controller.userData.isSelecting ) {

                const object = room.children[ count ++ ];

                object.position.copy( controller.position );
                object.userData.velocity.x = ( Math.random() - 0.5 ) * 3;
                object.userData.velocity.y = ( Math.random() - 0.5 ) * 3;
                object.userData.velocity.z = ( Math.random() - 9 );
                object.userData.velocity.applyQuaternion( controller.quaternion );

                if ( count === room.children.length ) count = 0;
            }
        }

        // Window resize
        function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		window.addEventListener( 'resize', onWindowResize, false );

/////////////////////////////////////////
// https://github.com/mrdoob/three.js/blob/master/examples/webgl_decals.html
// https://threejs.org/docs/index.html?q=DecalGeometry#examples/en/geometries/DecalGeometry
        const textureLoader = new THREE.TextureLoader();
        const decalDiffuse = textureLoader.load( 'textures/decal/decal-diffuse.png' );
        const decalNormal = textureLoader.load( 'textures/decal/decal-normal.jpg' );
        const decals = [];

        // function shoot(euler) { 
            const decalMaterial = new THREE.MeshPhongMaterial( {
				specular: 0x444444,
				map: decalDiffuse,
				normalMap: decalNormal,
				normalScale: new THREE.Vector2( 1, 1 ),
				shininess: 30,
				transparent: true,
				depthTest: true,
				depthWrite: false,
				polygonOffset: true,
				polygonOffsetFactor: - 4,
				wireframe: false
			} );
            let mesh;
            const position = new THREE.Vector3(0,0,0);
			const euler = new THREE.Euler(0, 0, -1, "XYZ");
			const size = new THREE.Vector3( 0.5, 0.5, 0.5 );

			// const params = {
			// 	minScale: 10,
			// 	maxScale: 20,
			// 	rotate: true,
			// 	clear: function () {
			// 		removeDecals();
			// 	}
			// };

            // const scale = params.minScale + Math.random() * ( params.maxScale - params.minScale );
            // size.set( scale, scale, scale );

            // const material = decalMaterial.clone();
            // material.color.setHex( Math.random() * 0xffffff );

            const m = new THREE.Mesh( new DecalGeometry( mesh, position, euler, size ), material );

        //     decals.push( m );
            scene.add( m );
        // }

        // function removeDecals() {
        //     decals.forEach( function ( d ) {
        //         scene.remove( d );
        //     } );
        //     decals.length = 0;

        // }
///////////////////////////////////////////////

        // 
        function render() {
            handleController( controller1 );
            handleController( controller2 );

            const delta = clock.getDelta() * 0.8;   // Slow down simulation
            const range = 5 - radius;              // Ball shooting range

            for ( let i = 0; i < room.children.length; i ++ ) {

                const object = room.children[ i ];

                object.position.x += object.userData.velocity.x * delta;
                object.position.y += object.userData.velocity.y * delta;
                object.position.z += object.userData.velocity.z * delta;

                // keep objects inside room

                if ( object.position.x < - range || object.position.x > range ) {
                    object.position.x = THREE.MathUtils.clamp( object.position.x, - range, range );
                    object.userData.velocity.x = - object.userData.velocity.x;
                }

                if ( object.position.y < radius || object.position.y > 6 ) {
                    object.position.y = Math.max( object.position.y, radius );

                    object.userData.velocity.x *= 0.98;
                    object.userData.velocity.y = - object.userData.velocity.y * 0.8;
                    object.userData.velocity.z *= 0.98;
                }

                if ( object.position.z < - range || object.position.z > range ) {
                    object.position.z = THREE.MathUtils.clamp( object.position.z, - range, range );
                    object.userData.velocity.z = - object.userData.velocity.z;
                }
//////////////////////////////////////////////////////////////////////
                // if (object.position.x == range) {
                    // shoot(0);
                // }
//////////////////////////////////////////////////////////////////////
                for ( let j = i + 1; j < room.children.length; j ++ ) {
                    const object2 = room.children[ j ];

                    normal.copy( object.position ).sub( object2.position );

                    const distance = normal.length();

                    if ( distance < 2 * radius ) {
                        normal.multiplyScalar( 0.5 * distance - radius );

                        object.position.sub( normal );
                        object2.position.add( normal );

                        normal.normalize();

                        relativeVelocity.copy( object.userData.velocity ).sub( object2.userData.velocity );

                        normal = normal.multiplyScalar( relativeVelocity.dot( normal ) );

                        object.userData.velocity.sub( normal );
                        object2.userData.velocity.add( normal );
                    }
                }
                object.userData.velocity.y -= 9.8 * delta;
            }
        }

        renderer.setAnimationLoop( function () {
            render();
			renderer.render( scene, camera );
		});

		// Add helper
		scene.add( new THREE.AxesHelper( 5 ) );
		scene.add( new THREE.CameraHelper( spotLight.shadow.camera ) );
		scene.add( new THREE.GridHelper( 10, 10 ) );


    </script>
</body>

</html>